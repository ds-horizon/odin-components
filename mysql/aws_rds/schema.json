{
  "title": "aws_rds provisioning configuration",
  "type": "object",
  "properties": {
    "engineVersion": {
      "type": "string",
      "description": "The Aurora MySQL engine version for the cluster. Determines available features, performance characteristics, and compatibility with MySQL clients. Specify the full version number (e.g., 3.04.2 for MySQL 8.0.28 compatibility, 3.05.1 for MySQL 8.0.32). Different versions support different features like backtrack, specific parameter groups, and performance improvements. Major version changes require careful testing of application compatibility. Check AWS documentation for available versions and deprecation timelines. **Production:** Use latest stable version in your MySQL compatibility series for security patches and bug fixes."
    },
    "dbName": {
      "type": "string",
      "description": "The name of the initial database created automatically when the cluster is provisioned. Applications connect to this database by default. Must start with a letter and contain only alphanumeric characters and underscores (1-64 characters). Additional databases can be created after provisioning via SQL. Leave empty when restoring from snapshot (uses snapshot's databases) or creating a read replica (replicates source databases). **Production:** Use descriptive names matching your application or microservice name for clarity.",
      "minLength": 1,
      "maxLength": 64,
      "pattern": "^[A-Za-z][A-Za-z0-9_]*$"
    },
    "port": {
      "type": "integer",
      "description": "The TCP port number on which the database accepts connections. All instances in the cluster use the same port. Valid range is 1150-65535. Custom ports can provide security through obscurity but require updating application connection strings and firewall rules. **Default: 3306** (standard MySQL port for maximum compatibility). **Production:** Use default 3306 unless security policies mandate non-standard ports.",
      "minimum": 1150,
      "maximum": 65535
    },
    "storageType": {
      "type": "string",
      "enum": [
        "aurora",
        "aurora-iopt1"
      ],
      "description": "The storage type for the Aurora cluster. Determines pricing model and cost structure for I/O operations. 'aurora' uses standard Aurora storage where you pay per I/O request (cost-effective for low to moderate I/O). 'aurora-iopt1' (I/O-Optimized) includes unlimited I/O operations in the price (better for I/O-intensive workloads with >$8000/month I/O costs). Cannot be changed after cluster creation. **Default: aurora** (predictable costs for most workloads). **Production:** Choose 'aurora-iopt1' only if I/O costs consistently exceed 25% of total Aurora costs."
    },
    "backupRetentionPeriod": {
      "type": "integer",
      "description": "The number of days to retain automated backups before automatic deletion. AWS takes daily backups during the preferred backup window and retains them for this period. Enables point-in-time recovery to any second within the retention period. Minimum 1 day, maximum 35 days. Longer retention increases backup storage costs but improves recovery options. Backtrack (if enabled) provides faster recovery than backup restoration. **Default: 7** (one week of recovery history, balancing cost and safety). **Production:** Use 7-35 days based on compliance requirements and change frequency.",
      "minimum": 1,
      "maximum": 35
    },
    "preferredBackupWindow": {
      "type": "string",
      "description": "The daily time range during which automated backups are created, in UTC timezone. Must be at least 30 minutes long and cannot overlap with the maintenance window. Format: hh24:mi-hh24:mi (e.g., '03:00-04:00' for 3-4 AM UTC). Backups may cause brief I/O suspension on single-AZ deployments. Choose low-traffic periods to minimize application impact. If not specified, AWS assigns a random default window. **Production:** Set explicitly to a known low-traffic period based on your user time zones.",
      "pattern": "^\\d{2}:\\d{2}-\\d{2}:\\d{2}$"
    },
    "preferredMaintenanceWindow": {
      "type": "string",
      "description": "The weekly time range for system maintenance including minor version upgrades, security patches, and OS updates, in UTC timezone. Must be at least 30 minutes long and cannot overlap with the backup window. Format: ddd:hh24:mi-ddd:hh24:mi (e.g., 'Mon:03:00-Mon:04:00'). During maintenance, instances may restart causing brief downtime (typically 1-3 minutes with Multi-AZ). Maintenance happens only when necessary, not every week. If not specified, AWS assigns a random default window. **Production:** Set explicitly to your lowest-traffic day and time, considering multi-region deployments.",
      "pattern": "^\\d{2}:\\d{2}-\\d{2}:\\d{2}$"
    },
    "copyTagsToSnapshot": {
      "type": "boolean",
      "description": "Automatically copies all cluster tags to snapshots and backups when created. Maintains consistent tagging across cluster and backups for cost allocation, compliance tracking, automation scripts, and resource organization. Tags include custom tags and AWS-managed tags. Useful for tracking backup costs per environment or application. No performance impact. **Default: true** (ensures backup tagging consistency). **Production:** Keep enabled for comprehensive cost tracking and compliance auditing."
    },
    "deletionProtection": {
      "type": "boolean",
      "description": "Prevents the database cluster from being deleted until explicitly disabled. Acts as a safeguard against accidental deletions from human error, automation bugs, or malicious actions. When enabled, deletion API calls fail immediately. Must be disabled before cluster deletion (requires separate API call). No performance or cost impact. **Default: false** (allows quick iteration in development). **Production:** Enable for all production databases containing critical data."
    },
    "encryptionAtRest": {
      "type": "boolean",
      "description": "Encrypts database storage, automated backups, snapshots, and read replicas using AWS KMS AES-256 encryption. Encryption is irreversible - encrypted clusters cannot be unencrypted later. Operates transparently at the storage layer with no application changes required. Performance impact is minimal (<5%). Required for compliance standards (HIPAA, PCI-DSS, SOC 2) and protecting sensitive data. Encrypted snapshots cannot be shared with accounts that lack access to the KMS key. **Default: false** (reduces complexity for development). **Production:** Enable for all databases containing sensitive or regulated data."
    },
    "kmsKeyId": {
      "type": "string",
      "description": "The ARN of a customer-managed AWS KMS key for cluster encryption when encryptionAtRest is enabled. Custom keys provide granular control over key policies, rotation schedules, cross-account access, and CloudTrail audit logs of key usage. If omitted, AWS uses the default service-managed key (aws/rds). Custom keys allow disabling encryption by revoking key access and enable sharing encrypted snapshots across accounts. Incurs KMS API call costs (~$0.03 per 10,000 requests). Format: arn:aws:kms:region:account-id:key/key-id. **Production:** Use custom keys for auditing requirements or cross-account snapshot sharing.",
      "pattern": "^arn:(aws|aws-cn|aws-us-gov):kms:[a-z0-9-]+:\\d{12}:key\\/[0-9a-fA-F-]{36}$"
    },
    "enableIAMDatabaseAuthentication": {
      "type": "boolean",
      "description": "Enables authentication using AWS IAM roles and users instead of database passwords. Applications request temporary 15-minute authentication tokens from AWS STS, eliminating static password storage and rotation. Tokens are generated using IAM credentials and database user mapping. Requires application code changes to use IAM token generation. Improves security through centralized access control, automatic credential rotation, and CloudTrail audit logging. Useful for applications on EC2, ECS, Lambda, or any service with IAM roles. Maximum 200 IAM connections per second. **Default: false** (simplifies initial setup). **Production:** Enable for applications with IAM roles to eliminate password management."
    },
    "enableCloudwatchLogsExports": {
      "type": "array",
      "description": "List of database log types to publish to CloudWatch Logs for centralized monitoring, analysis, and alerting. Available types: 'error' (MySQL error logs), 'general' (all queries - high volume, use sparingly), 'slowquery' (queries exceeding long_query_time threshold), 'instance' (instance lifecycle events), 'iam-db-auth-error' (IAM authentication failures), 'audit' (compliance audit logs if configured). Logs are published continuously with ~5 second delay. Incurs CloudWatch Logs storage costs ($0.50/GB ingested, $0.03/GB stored). High-traffic databases with 'general' logging can generate 10s of GB daily. Must also enable corresponding instance parameter (e.g., slow_query_log=1). **Production:** Enable 'error' and 'slowquery' for troubleshooting; use 'audit' for compliance; avoid 'general' except for short-term debugging.",
      "items": {
        "type": "string",
        "enum": [
          "error",
          "general",
          "slowquery",
          "instance",
          "iam-db-auth-error",
          "audit"
        ]
      },
      "uniqueItems": true
    },
    "snapshotIdentifier": {
      "type": "string",
      "description": "The identifier of an existing DB cluster snapshot to restore from when creating a new cluster. Creates a new cluster with data, schema, and configuration from the snapshot. Useful for cloning databases, disaster recovery, creating test environments from production snapshots, or migrating databases. Credentials and master username are inherited from the snapshot - do not provide credentials parameter. Engine version can be upgraded during restore but not downgraded. Cannot be used with replicationSourceIdentifier. Restore time depends on data size (typically minutes for Aurora due to lazy loading). **Production:** Use for blue-green deployments and creating staging environments from production data."
    },
    "replicationSourceIdentifier": {
      "type": "string",
      "description": "The ARN of the source Aurora cluster to create a read-only cross-region replica from. Establishes physical replication between regions using Aurora's binlog-based replication. Use for disaster recovery (enables promotion to standalone cluster), geographic data distribution (serves reads from multiple regions), or reducing read latency for global users. Replica continuously receives changes with typical lag <1 second. Replication lag increases with high write loads or network issues. Cannot be used with snapshotIdentifier. Requires source cluster to have backtrackWindow=0. Incurs cross-region data transfer costs (~$0.02/GB). Credentials are replicated from source - do not provide credentials parameter. **Production:** Essential for multi-region disaster recovery and global read scaling."
    },
    "sourceRegion": {
      "type": "string",
      "description": "The AWS region code of the source cluster when creating a cross-region read replica. Required only when replicationSourceIdentifier specifies a cluster in a different region. Helps AWS establish optimized replication channels and encrypted connections between regions. Format: standard AWS region code (e.g., 'us-east-1', 'eu-west-1', 'ap-south-1'). Must be a valid region where Aurora is available. **Production:** Always specify when using cross-region replication to ensure proper replication setup.",
      "pattern": "^[a-z]{2}-[a-z]+-\\d$"
    },
    "globalClusterIdentifier": {
      "type": "string",
      "description": "The identifier of an Aurora Global Database to join or create. Aurora Global Database spans multiple AWS regions with one primary (write) region and up to 5 secondary (read-only) regions. Provides low-latency global reads (<1 second replication lag), fast disaster recovery (region-level failover in <1 minute), and improved business continuity. Storage-level replication is more efficient than binlog-based replication. Use for globally distributed applications requiring fast local reads. Each region runs a full Aurora cluster. Incurs cross-region data transfer costs. Managed differently than standard cross-region replicas. **Production:** Use for multi-region applications requiring fast failover and low read latency worldwide."
    },
    "serverlessV2ScalingConfiguration": {
      "type": "object",
      "description": "Scaling configuration for Aurora Serverless v2 instances. Required when any instance (writer or reader) uses db.serverless instance type. Aurora Serverless v2 automatically scales compute capacity in fine-grained increments based on CPU utilization, connections, and memory usage. Scales in seconds (not minutes like Serverless v1). Provides cost efficiency for variable workloads while maintaining millisecond-latency consistent performance. Scaling boundaries apply cluster-wide to all serverless instances.",
      "properties": {
        "minCapacity": {
          "type": "number",
          "description": "Minimum Aurora Capacity Units (ACUs) for serverless instances. One ACU provides 2 GiB memory plus corresponding CPU and networking. Instances scale down to this floor during idle periods. Lower values (0.5-1) minimize idle costs but may have slower response to sudden load spikes. Higher values (2-8) ensure baseline performance for steady workloads. Minimum value is 0.5 ACU (~$0.06/hour). Scaling granularity is 0.5 ACU increments. **Production:** Set based on baseline load; use 0.5-1 for dev/test, 2-4 for variable production workloads, 8+ for predictable production workloads.",
          "minimum": 0.5
        },
        "maxCapacity": {
          "type": "number",
          "description": "Maximum Aurora Capacity Units (ACUs) for serverless instances. Defines the scaling ceiling - instances cannot scale beyond this limit. Higher values (16-128) handle traffic spikes but increase maximum hourly cost. Lower values (1-8) control costs but may cause throttling during spikes. Must be >= minCapacity. Maximum value is 128 ACUs (~$15.36/hour). Aurora scales up automatically within seconds when CPU/memory usage exceeds thresholds. **Production:** Set to 2-4x your peak historical load to handle unexpected spikes; monitor scaling metrics to adjust.",
          "minimum": 0.5
        }
      },
      "required": [
        "minCapacity",
        "maxCapacity"
      ],
      "additionalProperties": false
    },
    "backtrackWindow": {
      "type": "integer",
      "minimum": 0,
      "description": "The target backtrack window in seconds for in-place rewind capability. Aurora Backtrack allows rewinding the database to any point in time within this window without restoring from backup. Rewind completes in minutes (vs hours for backup restore). Uses change records stored in the cluster, incurring storage costs. Value of 0 disables backtrack (no additional costs). Maximum is 259200 seconds (72 hours). Only supported on some Aurora MySQL versions (check compatibility). Useful for quickly recovering from user errors, application bugs, or bad migrations. Cannot be used with Global Databases or cross-region replicas. **Default: 0** (disabled to minimize storage costs). **Production:** Enable with 24-72 hours for critical databases where fast recovery justifies cost."
    },
    "credentials": {
      "type": "object",
      "description": "Master user credentials for initial database authentication and administration. Choose exactly one of three methods: (1) masterUserPassword - plain text password (not recommended for production), (2) masterUserSecretKmsKeyId - AWS auto-generates password stored in Secrets Manager encrypted with your KMS key, (3) manageMasterUserPassword=true - AWS auto-generates and stores password in Secrets Manager with default encryption. Not required when restoring from snapshot or creating read replica. **Production:** Use manageMasterUserPassword or masterUserSecretKmsKeyId for automatic secret management and rotation.",
      "properties": {
        "masterUsername": {
          "type": "string",
          "description": "The master (root) username for the database with full administrative privileges. Used for initial setup, user management, and emergency access. Cannot be AWS reserved words: 'admin', 'root', 'rdsadmin', or other MySQL reserved words. Must start with a letter and contain only alphanumeric characters and underscores. Length: 1-16 characters. Create application-specific users with limited privileges after cluster creation. **Production:** Use a non-obvious name (not 'admin' or 'root') for additional security through obscurity.",
          "minLength": 1,
          "maxLength": 16
        },
        "masterUserPassword": {
          "type": "string",
          "description": "The password for the master user in plain text. Must be 8-128 characters long. Can include printable ASCII characters except '/', '@', '\"', and space. Password is stored encrypted at rest but appears in API calls and CloudFormation templates. Not recommended for production due to exposure risk in code repositories and logs. Mutually exclusive with manageMasterUserPassword and masterUserSecretKmsKeyId. **Production:** Do not use; prefer AWS Secrets Manager managed passwords for security.",
          "minLength": 8,
          "maxLength": 128
        },
        "masterUserSecretKmsKeyId": {
          "type": "string",
          "description": "The ARN of a customer-managed KMS key to encrypt the auto-generated master password in AWS Secrets Manager. AWS generates a strong random password, stores it in Secrets Manager, and encrypts it with this key. Provides audit trail via CloudTrail KMS key usage logs. Password rotation can be managed via Secrets Manager. Retrieve password programmatically via Secrets Manager API. Mutually exclusive with masterUserPassword and manageMasterUserPassword. Format: arn:aws:kms:region:account-id:key/key-id. **Production:** Use when you need customer-managed key controls for compliance or cross-account secret access.",
          "pattern": "^arn:(aws|aws-cn|aws-us-gov):kms:[a-z0-9-]+:\\d{12}:key\\/[0-9a-fA-F-]{36}$"
        },
        "manageMasterUserPassword": {
          "type": "boolean",
          "description": "When true, AWS auto-generates a strong random password and stores it in AWS Secrets Manager encrypted with the default RDS service key. Eliminates password management burden and exposure risk. Password is retrievable via Secrets Manager API using the cluster ARN. Enables automatic password rotation via Secrets Manager. Mutually exclusive with masterUserPassword and masterUserSecretKmsKeyId. Must be explicitly set to true. **Production:** Recommended for most production deployments for simplicity and security."
        }
      },
      "additionalProperties": false,
      "required": [
        "masterUsername"
      ],
      "oneOf": [
        {
          "required": [
            "masterUserPassword"
          ]
        },
        {
          "required": [
            "masterUserSecretKmsKeyId"
          ]
        },
        {
          "required": [
            "manageMasterUserPassword"
          ],
          "properties": {
            "manageMasterUserPassword": {
              "const": true
            }
          }
        }
      ],
      "allOf": [
        {
          "if": {
            "required": [
              "masterUserPassword"
            ]
          },
          "then": {
            "not": {
              "anyOf": [
                {
                  "required": [
                    "masterUserSecretKmsKeyId"
                  ]
                },
                {
                  "properties": {
                    "manageMasterUserPassword": {
                      "const": true
                    }
                  }
                }
              ]
            }
          }
        },
        {
          "if": {
            "required": [
              "masterUserSecretKmsKeyId"
            ]
          },
          "then": {
            "not": {
              "anyOf": [
                {
                  "required": [
                    "masterUserPassword"
                  ]
                },
                {
                  "properties": {
                    "manageMasterUserPassword": {
                      "const": true
                    }
                  }
                }
              ]
            }
          }
        },
        {
          "if": {
            "properties": {
              "manageMasterUserPassword": {
                "const": true
              }
            }
          },
          "then": {
            "not": {
              "anyOf": [
                {
                  "required": [
                    "masterUserPassword"
                  ]
                },
                {
                  "required": [
                    "masterUserSecretKmsKeyId"
                  ]
                }
              ]
            }
          }
        }
      ]
    },
    "clusterParameterGroupName": {
      "type": "string",
      "description": "The name of a pre-existing DB cluster parameter group to attach. Cluster parameter groups contain engine configuration values applying cluster-wide to all instances (writer and readers). Use when parameter group is managed externally or shared across multiple clusters. AWS provides default parameter groups (e.g., 'default.aurora-mysql8.0') which cannot be modified. For custom parameters, create a custom parameter group first. Mutually exclusive with clusterParameterGroupConfig. Changes to parameter group may require instance restart. **Production:** Use pre-created parameter groups for standardized configurations across environments."
    },
    "clusterParameterGroupConfig": {
      "type": "object",
      "description": "Define cluster-level parameters inline without pre-creating a parameter group. Platform automatically creates a new custom parameter group with these values, applies it to the cluster, and manages its lifecycle. Settings apply cluster-wide to all instances. Use for self-contained configuration management. Mutually exclusive with clusterParameterGroupName. Parameter changes may require instance restart depending on dynamic/static classification. **Production:** Useful for infrastructure-as-code where configuration is version controlled with cluster definition.",
      "properties": {
        "binlogFormat": {
          "type": "string",
          "description": "The binary log format controlling how changes are recorded for replication and point-in-time recovery. 'ROW' records actual row changes (recommended for data consistency and avoiding replication bugs). 'OFF' disables binary logging entirely, reducing storage I/O and write overhead by ~10-15% but disabling PITR, read replicas, and cross-region replication. Changes require instance restart. **Default:** 'ROW' in most versions. **Production:** Keep 'ROW' unless you disable all replication/backup features and accept data loss risk.",
          "enum": [
            "ROW",
            "OFF"
          ]
        },
        "innodbPrintAllDeadlocks": {
          "type": "string",
          "description": "Controls whether all InnoDB deadlock information is printed to the error log. '1' enables logging of all deadlocks with full transaction details and lock wait information (useful for debugging concurrency issues). '0' disables (only latest deadlock visible via SHOW ENGINE INNODB STATUS). Enabling increases error log volume proportional to deadlock frequency. Dynamic parameter, no restart required. **Default:** '0'. **Production:** Enable temporarily when diagnosing deadlock issues, disable after resolution to reduce log noise.",
          "enum": ["0", "1"]
        },
        "awsDefaultLambdaRole": {
          "type": "string",
          "description": "The ARN of an IAM role allowing Aurora to invoke AWS Lambda functions from SQL. Required for native Lambda integration via mysql.lambda_async stored procedure. The role must have lambda:InvokeFunction permission and trust policy allowing rds.amazonaws.com. Enables event-driven workflows, notifications, and hybrid processing from within database. Format: arn:aws:iam::account-id:role/role-name. **Production:** Use only if integrating database triggers with Lambda; keep unset otherwise for principle of least privilege.",
          "pattern": "^arn:(aws|aws-cn|aws-us-gov):iam::\\d{12}:role\\/.+"
        },
        "awsDefaultS3Role": {
          "type": "string",
          "description": "The ARN of an IAM role allowing Aurora to access Amazon S3 for bulk data operations. Required for LOAD DATA FROM S3 (importing files) and SELECT INTO OUTFILE S3 (exporting query results). The role must have s3:GetObject (for import) and s3:PutObject (for export) permissions plus trust policy allowing rds.amazonaws.com. Enables efficient ETL operations. Format: arn:aws:iam::account-id:role/role-name. **Production:** Essential for data warehouse ETL pipelines and bulk data migrations.",
          "pattern": "^arn:(aws|aws-cn|aws-us-gov):iam::\\d{12}:role\\/.+"
        },
        "awsDefaultLogsRole": {
          "type": "string",
          "description": "The ARN of an IAM role allowing Aurora to publish database logs to CloudWatch Logs. Required only if using advanced audit logging beyond standard error/slow query logs. The role must have logs:CreateLogGroup, logs:CreateLogStream, and logs:PutLogEvents permissions with trust policy allowing rds.amazonaws.com. Most use cases don't require this - use enableCloudwatchLogsExports instead. Format: arn:aws:iam::account-id:role/role-name. **Production:** Rarely needed; only for custom audit plugin configurations.",
          "pattern": "^arn:(aws|aws-cn|aws-us-gov):iam::\\d{12}:role\\/.+"
        }
      },
      "additionalProperties": false
    },
    "deletionConfig": {
      "type": "object",
      "description": "Configuration controlling cluster deletion behavior and final backup creation. Determines whether a final snapshot is automatically created before cluster deletion for disaster recovery. Final snapshots are manual snapshots that persist indefinitely until explicitly deleted, enabling cluster restoration even after deletion. **Production:** Always configure to create final snapshots for production databases; skip only for temporary dev/test clusters.",
      "properties": {
        "skipFinalSnapshot": {
          "type": "boolean",
          "description": "Controls final snapshot creation on cluster deletion. When true, cluster is deleted immediately without creating a final snapshot (faster deletion, typically completes in 5-10 minutes, but no recovery option). When false, creates a final snapshot before deletion (adds 10-30 minutes but enables data recovery). Final snapshots have no expiration and incur storage costs (~$0.095/GB-month) until manually deleted. **Default: true** (does not create snapshot). **Production:** Set to false for all production and staging databases; use true only for ephemeral dev/test clusters."
        },
        "finalSnapshotIdentifier": {
          "type": "string",
          "description": "The identifier for the final snapshot created during cluster deletion. Required when skipFinalSnapshot is false. Must be unique within your AWS account and region. Cannot be modified after snapshot creation. Use descriptive naming convention including cluster name, environment, and timestamp for easy identification (e.g., 'myapp-prod-cluster-final-20250130'). Snapshot remains until manually deleted. **Production:** Use consistent naming convention across organization for snapshot lifecycle management.",
          "pattern": "^[a-zA-Z][a-zA-Z0-9-]{0,254}$"
        }
      },
      "allOf": [
        {
          "if": {
            "properties": {
              "skipFinalSnapshot": {
                "const": false
              }
            }
          },
          "then": {
            "required": [
              "finalSnapshotIdentifier"
            ]
          }
        },
        {
          "if": {
            "properties": {
              "skipFinalSnapshot": {
                "const": true
              }
            }
          },
          "then": {
            "not": {
              "required": [
                "finalSnapshotIdentifier"
              ]
            }
          }
        }
      ],
      "required": [
        "skipFinalSnapshot"
      ],
      "additionalProperties": false
    },
    "tags": {
      "type": "object",
      "description": "Key-value pairs to tag the Aurora cluster and all its instances for organization, cost tracking, access control, and automation. Tags are propagated to automated backups if copyTagsToSnapshot is enabled. Use for: (1) Cost allocation - track costs per team/project/environment in billing reports, (2) Access control - conditional IAM policies based on tags, (3) Automation - identify resources for backup/monitoring/compliance scripts, (4) Organization - search and filter resources in console. Tag keys cannot start with 'aws:' (reserved prefix). Key length: 1-128 characters. Value length: 0-256 characters. Maximum 50 tags per resource. Common tags: Environment (dev/staging/prod), Application, Owner, CostCenter. **Production:** Use consistent tagging strategy across organization for effective governance and cost management.",
      "patternProperties": {
        "^(?!aws:).+": {
          "type": [
            "string",
            "number",
            "boolean"
          ]
        }
      },
      "additionalProperties": false
    },
    "instanceConfig": {
      "type": "object",
      "description": "Common configuration settings applied as defaults to all DB instances in the cluster (writer and readers). Acts as a template providing baseline configuration. Individual instances can override these settings in the writer or readers sections. Use to standardize configuration like monitoring, networking, and parameter groups across the cluster while allowing per-instance customization where needed. **Production:** Define security and monitoring settings here to ensure consistent baseline across all instances.",
      "properties": {
        "availabilityZone": {
          "type": "string",
          "description": "The specific AWS Availability Zone for instance placement (e.g., 'us-east-1a', 'eu-west-1b'). If omitted, AWS automatically distributes instances across AZs for high availability. Aurora automatically manages cross-AZ replication and failover. Specify only for: (1) Co-locating with specific application servers to reduce latency, (2) Compliance requirements for data residency. Note: Constraining AZ placement reduces AWS's flexibility for optimal resource allocation. Format: {region}{zone-letter}. **Production:** Leave unspecified to allow AWS optimal placement unless you have specific latency or compliance requirements.",
          "pattern": "^[a-z]{2}-[a-z]+-\\d[a-z]?$"
        },
        "publiclyAccessible": {
          "type": "boolean",
          "description": "Controls whether instances receive public IP addresses and DNS names accessible from the internet. When true, instances get public IPs but still require security group rules allowing inbound traffic (not automatically open). When false, instances are private with VPC-internal IPs only, accessible via VPN, Direct Connect, or bastion hosts. Public access simplifies connectivity but increases attack surface. Security groups should restrict public access to specific IPs. **Default: false** (VPC-only access for security). **Production:** Keep false for production databases; use VPN/bastion for administrative access. Enable only for dev/test databases requiring internet access."
        },
        "autoMinorVersionUpgrade": {
          "type": "boolean",
          "description": "Controls automatic application of minor engine version upgrades during maintenance windows. When enabled, AWS applies minor version patches (e.g., 3.04.0 → 3.04.1) automatically for security fixes and bug fixes. Minor upgrades are backward-compatible and typically don't require application changes. Upgrades occur during the maintenance window causing brief downtime (1-3 minutes). When disabled, you control upgrade timing manually. AWS notifies of available upgrades via console/API. **Default: true** (automatic security patching). **Production:** Keep enabled for automated security maintenance, but test new versions in staging first; temporarily disable before critical business periods."
        },
        "enablePerformanceInsights": {
          "type": "boolean",
          "description": "Enables Amazon RDS Performance Insights for advanced database performance monitoring and troubleshooting. Provides real-time and historical views of database load broken down by waits, SQL statements, hosts, and users. Shows top SQL queries by execution time, I/O, CPU. Helps identify bottlenecks like lock contention, I/O waits, CPU saturation. Data is collected at 1-second granularity with minimal performance impact (<1% CPU overhead). Includes free tier with 7-day retention. Additional retention (up to 2 years) incurs charges (~$0.0116/vCPU/day). Independent of CloudWatch metrics. **Default: false** (reduces costs for dev/test). **Production:** Enable for all production databases to facilitate performance troubleshooting and capacity planning."
        },
        "performanceInsightsKmsKeyId": {
          "type": "string",
          "description": "The ARN of a customer-managed KMS key to encrypt Performance Insights data at rest. If omitted, AWS uses the default service-managed RDS KMS key. Custom keys provide: (1) Control over key policies and cross-account access, (2) CloudTrail audit logs of key usage, (3) Ability to disable encryption by revoking key access. Required only when Performance Insights is enabled and compliance requires customer-managed keys. Incurs KMS API costs (~$0.03 per 10,000 requests). Format: arn:aws:kms:region:account-id:key/key-id. **Production:** Use customer-managed keys only for compliance requirements (HIPAA, PCI-DSS); default encryption is sufficient for most use cases.",
          "pattern": "^arn:(aws|aws-cn|aws-us-gov):kms:[a-z0-9-]+:\\d{12}:key\\/[0-9a-fA-F-]{36}$"
        },
        "performanceInsightsRetentionPeriod": {
          "type": "integer",
          "description": "The retention period for Performance Insights data in days. Determines how far back you can analyze historical performance. 7 days (free tier, included with Performance Insights, sufficient for recent troubleshooting). 731 days (2 years, additional cost ~$3.50/vCPU/month, enables long-term trend analysis and capacity planning). Data older than retention period is automatically deleted. Cannot be changed to shorter period without recreating instance. **Default: 7** (free tier). **Production:** Use 7 days for most databases; choose 731 days for critical production databases requiring long-term performance trending and capacity forecasting.",
          "enum": [
            7,
            731
          ]
        },
        "enhancedMonitoring": {
          "type": "object",
          "description": "Enhanced Monitoring provides real-time operating system-level metrics beyond standard CloudWatch database metrics. Collects 50+ OS metrics including per-process CPU utilization, per-disk I/O metrics, file system utilization, memory allocation (active/inactive/buffers/cached), and network bandwidth. Metrics are published to CloudWatch Logs (not CloudWatch Metrics) for querying and analysis. Useful for diagnosing OS-level performance issues, identifying resource contention, and capacity planning. Incurs CloudWatch Logs costs (~$0.50/GB ingested). Required for some support cases.",
          "properties": {
            "enabled": {
              "type": "boolean",
              "description": "Enables Enhanced Monitoring collection. When true, must provide interval and monitoringRoleArn. Provides significantly more detailed metrics than standard CloudWatch monitoring (which shows only database-level aggregates). Useful for troubleshooting performance issues caused by OS-level resource contention, identifying specific processes consuming resources, and detailed I/O analysis per disk. **Default: false** (disabled to reduce costs and complexity). **Production:** Enable for production databases experiencing performance issues or requiring detailed capacity planning data."
            },
            "interval": {
              "type": "integer",
              "description": "The monitoring data collection and publishing interval in seconds. Determines granularity of metrics. Smaller intervals provide more granular data for pinpointing transient issues but increase CloudWatch Logs costs proportionally. 60 seconds (standard, sufficient for most monitoring and alerting). 30 seconds (higher resolution trending). 15/10/5 seconds (detailed troubleshooting). 1 second (maximum granularity for real-time problem diagnosis). Cost impact: 1-second interval generates 60x more data than 60-second. **Production:** Use 60 seconds for routine monitoring; temporarily lower to 1-5 seconds during active troubleshooting.",
              "enum": [
                1,
                5,
                10,
                15,
                30,
                60
              ]
            },
            "monitoringRoleArn": {
              "type": "string",
              "description": "The ARN of an IAM role allowing RDS to publish enhanced monitoring metrics to CloudWatch Logs. The role must have: (1) Trust policy allowing monitoring.rds.amazonaws.com to assume the role, (2) Permissions policy with logs:CreateLogGroup, logs:CreateLogStream, logs:PutLogEvents actions. AWS provides a managed policy AmazonRDSEnhancedMonitoringRole for this purpose. One role can be shared across multiple instances. Format: arn:aws:iam::account-id:role/role-name. **Production:** Create a dedicated monitoring role once per AWS account and reuse across all RDS instances.",
              "pattern": "^arn:(aws|aws-cn|aws-us-gov):iam::\\d{12}:role\\/.+"
            }
          },
          "allOf": [
            {
              "if": {
                "properties": {
                  "enabled": {
                    "const": true
                  }
                }
              },
              "then": {
                "required": [
                  "interval",
                  "monitoringRoleArn"
                ]
              }
            }
          ],
          "required": [
            "enabled"
          ],
          "additionalProperties": false
        },
        "instanceParameterGroupName": {
          "type": "string",
          "description": "The name of a pre-existing DB instance parameter group to attach. Instance parameter groups control instance-level settings like connection limits, timeouts, query cache, buffer pools, and other MySQL session variables. Use when parameter group is managed externally or shared across clusters. Each instance can have different parameter groups. Changes to dynamic parameters take effect immediately; static parameters require instance restart. Mutually exclusive with instanceParameterGroupConfig. **Production:** Use pre-created parameter groups for standardized configurations tested across environments."
        },
        "instanceParameterGroupConfig": {
          "type": "object",
          "description": "Define instance-level MySQL parameters inline without pre-creating a parameter group. Platform automatically creates and manages a custom parameter group with these values. Controls instance behavior including connection management, query execution timeouts, logging, and memory allocation for temporary tables. Settings apply per instance. Useful for infrastructure-as-code where configuration is version-controlled with cluster definition. Mutually exclusive with instanceParameterGroupName. **Production:** Convenient for simple parameter customization without external parameter group management.",
          "properties": {
            "interactiveTimeout": {
              "type": "integer",
              "description": "Seconds the server waits for activity on an interactive connection before closing it. Interactive connections are those from mysql client with CLIENT_INTERACTIVE flag (e.g., mysql CLI). Prevents accumulation of idle admin sessions. Range: 1-31536000. **Default: 28800** (8 hours). **Production:** Keep default unless administrators need longer sessions for maintenance; lower to 3600-7200 seconds if unused admin sessions accumulate.",
              "minimum": 1,
              "maximum": 31536000
            },
            "waitTimeout": {
              "type": "integer",
              "description": "Seconds the server waits for activity on a non-interactive connection before closing it. Applies to application database connections. Idle connections consume resources (memory, connection slots). Lower values free up connections faster but may disconnect legitimate idle application connections (e.g., connection pools). Higher values accommodate long-running transactions but risk connection exhaustion. Range: 1-31536000. **Default: 28800** (8 hours). **Production:** Set to 300-600 seconds (5-10 minutes) for stateless applications; keep higher (3600+) for applications with long-running transactions.",
              "minimum": 1,
              "maximum": 31536000
            },
            "lockWaitTimeout": {
              "type": "integer",
              "description": "Seconds to wait for a metadata lock before timing out. Metadata locks protect table structure during DDL operations (ALTER TABLE, etc.). Long waits occur when DDL blocks on active queries. Very high default can cause DDL to block indefinitely, preventing deployments. Lower values fail DDL faster, allowing retry logic. Range: 1-31536000. **Default: 31536000** (1 year, effectively unlimited). **Production:** Set to 60-300 seconds to prevent DDL operations from blocking deployments indefinitely; implement retry logic for schema changes.",
              "minimum": 1,
              "maximum": 31536000
            },
            "longQueryTime": {
              "type": "integer",
              "description": "Seconds threshold for classifying queries as slow. Queries with execution time exceeding this are logged to slow query log (if slow_query_log=1). Essential for identifying performance issues and optimization opportunities. Set too low and logs become noisy; too high and you miss optimization targets. Range: 0-31536000. **Default: 10** (10 seconds). **Production:** Set to 1-2 seconds during performance tuning phases; increase to 5-10 seconds in stable production to capture only genuinely problematic queries.",
              "minimum": 0,
              "maximum": 31536000
            },
            "maxAllowedPacket": {
              "type": "integer",
              "description": "Maximum size in bytes for network packets, query strings, and intermediate results. Limits maximum size of INSERT/UPDATE statements and BLOB/TEXT data. Too small causes 'Packet too large' errors on bulk inserts or large BLOB operations. Too large increases memory usage. Must be multiple of 1024. Range: 1024-1073741824 (1KB-1GB). **Default: 4194304** (4MB, sufficient for most applications). **Production:** Keep default unless handling large BLOBs or bulk inserts; increase to 16-64MB for ETL workloads; avoid exceeding 256MB unless essential.",
              "minimum": 1024,
              "maximum": 1073741824
            },
            "slowQueryLog": {
              "type": "integer",
              "description": "Enables (1) or disables (0) slow query logging. When enabled, queries exceeding long_query_time are logged. Must be enabled for slow query logs to be exported to CloudWatch (via enableCloudwatchLogsExports). Essential for identifying unoptimized queries and performance bottlenecks. Minimal performance overhead (<1%). Dynamic parameter. **Default: 0** (disabled to reduce log volume in dev). **Production:** Enable (set to 1) for all production databases; export to CloudWatch for centralized analysis and alerting.",
              "enum": [0, 1]
            },
            "tmpTableSize": {
              "type": "integer",
              "description": "Maximum size in bytes for internal in-memory temporary tables created during query execution (GROUP BY, ORDER BY, DISTINCT, UNION). If temporary table exceeds this size, MySQL converts it from in-memory (fast) to on-disk MyISAM table (slow, causes disk I/O). Works with max_heap_table_size (effective limit is minimum of both). Increasing improves performance of complex queries but consumes more memory per connection. Range: 1024-4294967295. **Default: 16777216** (16MB). **Production:** Increase to 64-256MB for analytical workloads with complex queries; monitor memory usage to avoid OOM; keep default for OLTP workloads.",
              "minimum": 1024,
              "maximum": 4294967295
            },
            "maxHeapTableSize": {
              "type": "integer",
              "description": "Maximum size in bytes for user-created MEMORY tables and internal temporary tables. Works with tmp_table_size to limit in-memory temporary table size (effective limit is minimum of both). Affects performance of queries using temporary tables for sorting/grouping. Higher values improve query performance but increase per-connection memory usage. Range: 16384-4294967295. **Default: 16777216** (16MB). **Production:** Keep synchronized with tmp_table_size; increase both to 64-256MB for analytical queries; monitor total memory usage (max_heap_table_size × max_connections).",
              "minimum": 16384,
              "maximum": 4294967295
            }
          },
          "additionalProperties": false
        },
        "networkType": {
          "type": "string",
          "description": "The network protocol version for DB instance endpoints. 'IPV4' provides IPv4-only endpoints (default, maximum compatibility with existing applications and tools). 'DUAL' provides both IPv4 and IPv6 endpoints (required for IPv6-only applications). Dual stack requires VPC and subnet configuration supporting IPv6 (IPv6 CIDR blocks assigned). Most applications use IPv4; choose DUAL only if you have IPv6 requirements. Cannot be changed after cluster creation without recreating. **Default: IPV4** (universal compatibility). **Production:** Use IPV4 unless you have specific IPv6 requirements from applications or compliance mandates.",
          "enum": [
            "IPV4",
            "DUAL"
          ]
        }
      },
      "allOf": [
        {
          "not": {
            "allOf": [
              {
                "required": [
                  "instanceParameterGroupName"
                ]
              },
              {
                "required": [
                  "instanceParameterGroupConfig"
                ]
              }
            ]
          }
        }
      ],
      "additionalProperties": false
    },
    "writer": {
      "description": "Configuration for the primary (writer) DB instance. The writer is the single read-write instance handling all write operations (INSERT, UPDATE, DELETE, DDL) and can also serve read queries. Only one writer exists per cluster at a time. Aurora automatically promotes a reader to writer during failover based on promotion tier (typically 1-3 minutes downtime). The writer is the single point of failure for writes, making its reliability and sizing critical. Inherits configuration from instanceConfig unless overridden here. **Production:** Size writer for peak write workload plus expected read traffic; use at least 1 reader for high availability.",
      "type": "object",
      "properties": {
        "instanceType": {
          "type": "string",
          "description": "The compute instance class for the writer instance. Determines CPU, memory, and network capacity for write operations and any reads served by the writer. Use 'db.serverless' for Aurora Serverless v2 (auto-scales based on load), or provisioned instances (fixed capacity). Writer should be sized for: (1) Peak write throughput, (2) Buffer pool for working set (InnoDB), (3) Connection overhead, (4) Any read traffic not offloaded to readers. Changing provisioned writer instance type requires brief downtime (1-3 minutes). Memory-optimized (r-class) instances recommended for production. Format: db.{family}{generation}{g?}.{size} or db.serverless. **Production:** Start with db.r6g.large or larger based on workload; use Serverless v2 for variable workloads.",
          "pattern": "^(db\\.(?:[trm][0-9][a-z]?\\.(?:micro|small|medium|large|xlarge|\\d+x?large))|db\\.serverless)$"
        },
        "promotionTier": {
          "type": "integer",
          "description": "Failover priority for the writer instance. Although the writer is not promoted (it's already writer), this value is used if the cluster topology changes. Lower numbers indicate higher priority (0 = highest, 15 = lowest). During writer failure, Aurora promotes the reader with the lowest tier value. Typically set writer to tier 0 or 1 to maintain tier continuity. Ties are broken arbitrarily. Range: 0-15. **Production:** Set to 0 or 1 for consistency; ensure at least one reader has equal or lower tier for automatic failover.",
          "minimum": 0,
          "maximum": 15
        }
      },
      "required": [
        "instanceType"
      ]
    },
    "readers": {
      "type": "array",
      "description": "Array of reader instance group configurations. Each array entry defines a group of identical reader instances with the same characteristics. Readers are read-only replicas that share cluster storage (no data replication lag) and serve read traffic to scale horizontally. Readers enable: (1) Read scaling - distribute read queries across multiple instances, (2) High availability - provide failover targets for writer failure, (3) Zero-downtime maintenance - rolling updates across readers. Replication lag is typically <100ms. Applications must use read-only endpoints or connection pools aware of reader endpoints. Maximum 15 total reader instances across all groups. Each group can have different instance types for workload optimization (e.g., large readers for reporting, small readers for app queries). **Production:** Use at least 1 reader for HA; 2+ readers for read-heavy workloads; distribute across multiple AZs.",
      "items": {
        "type": "object",
        "description": "Configuration for a group of identical reader instances. Defines instance type, count, and failover priority for a set of readers. All readers in this group share the same configuration but can be distributed across availability zones automatically by Aurora. Use multiple groups to create heterogeneous reader topology (e.g., mix of large instances for analytics and small instances for operational queries). Each reader can be scaled independently by modifying instance count.",
        "required": [
          "instanceType",
          "instanceCount"
        ],
        "properties": {
          "instanceType": {
            "type": "string",
            "description": "The compute instance class for all reader instances in this group. Determines CPU, memory, and network capacity for read operations. Use 'db.serverless' for Aurora Serverless v2 (auto-scales), or provisioned instances (fixed capacity). Readers can be different sizes than the writer - common patterns: (1) Same size as writer for uniform load distribution, (2) Smaller than writer for cost optimization (readers handle only reads), (3) Larger than writer for dedicated analytics/reporting workloads. Changing reader instance type is online (no downtime). Memory-optimized (r-class) recommended. Format: db.{family}{generation}{g?}.{size} or db.serverless. **Production:** Size based on read workload distribution; start with db.r6g.large; use larger instances for dedicated analytical readers.",
            "pattern": "^(db\\.(?:[trm][0-9][a-z]?\\.(?:micro|small|medium|large|xlarge|\\d+x?large))|db\\.serverless)$"
          },
          "instanceCount": {
            "type": "integer",
            "description": "The number of identical reader instances to create in this group. Each instance is a full read replica with complete copy of cluster data (via shared storage). More readers improve: (1) Read throughput capacity, (2) Fault tolerance (multiple failover targets), (3) Maintenance flexibility (rolling updates). Considerations: Each reader adds cost (instance hours), requires connection pool capacity, and consumes cluster resources. Minimum 1 (for HA), maximum 15 total across all groups. Cost scales linearly with count. **Production:** Use 1 reader minimum for HA; 2-4 readers for moderate read traffic; 5+ for read-heavy workloads; add readers before peak periods.",
            "minimum": 1,
            "maximum": 15
          },
          "promotionTier": {
            "type": "integer",
            "description": "Failover priority for instances in this group during writer failure. Lower numbers = higher priority (0 = highest, 15 = lowest). When the writer fails, Aurora promotes the reader with the lowest tier value to become the new writer. Ties are broken by: (1) Largest instance size, (2) Arbitrary selection. Use tiers to: (1) Control which readers become writer (set lowest tier on largest/best-positioned readers), (2) Reserve specific readers for read-only workloads (set highest tier). All instances in this group share the same tier. Range: 0-15. **Production:** Set tier 0-1 for primary failover candidates (large instances in primary AZ); tier 5-10 for dedicated analytical readers (avoid promoting); tier 2-4 for general readers.",
            "minimum": 0,
            "maximum": 15
          }
        }
      }
    }
  },
  "required": [
    "engineVersion",
    "writer"
  ],
  "allOf": [
    {
      "not": {
        "allOf": [
          {
            "required": [
              "clusterParameterGroupName"
            ]
          },
          {
            "required": [
              "clusterParameterGroupConfig"
            ]
          }
        ]
      }
    },
    {
      "if": {
        "not": {
          "anyOf": [
            {
              "required": [
                "snapshotIdentifier"
              ]
            },
            {
              "required": [
                "replicationSourceIdentifier"
              ]
            }
          ]
        }
      },
      "then": {
        "required": [
          "credentials"
        ]
      }
    },
    {
      "if": {
        "anyOf": [
          {
            "required": [
              "snapshotIdentifier"
            ]
          },
          {
            "required": [
              "replicationSourceIdentifier"
            ]
          }
        ]
      },
      "then": {
        "not": {
          "required": [
            "credentials"
          ]
        }
      }
    },
    {
      "if": {
        "required": [
          "sourceRegion"
        ]
      },
      "then": {
        "required": [
          "replicationSourceIdentifier"
        ]
      }
    },
    {
      "if": {
        "properties": {
          "writer": {
            "properties": {
              "instanceType": {
                "const": "db.serverless"
              }
            },
            "required": [
              "instanceType"
            ]
          }
        }
      },
      "then": {
        "required": [
          "serverlessV2ScalingConfiguration"
        ]
      }
    },
    {
      "if": {
        "properties": {
          "readers": {
            "type": "array",
            "contains": {
              "properties": {
                "instanceType": {
                  "const": "db.serverless"
                }
              },
              "required": [
                "instanceType"
              ]
            }
          }
        }
      },
      "then": {
        "required": [
          "serverlessV2ScalingConfiguration"
        ]
      }
    }
  ],
  "additionalProperties": false
}
